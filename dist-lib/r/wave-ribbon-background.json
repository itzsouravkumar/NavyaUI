{
  "name": "wave-ribbon-background",
  "type": "registry:ui",
  "dependencies": [],
  "files": [
    {
      "path": "navyaui/WaveRibbonBackground.tsx",
      "content": "\"use client\";\nimport React, { useEffect, useRef } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface WaveRibbonBackgroundProps {\n    className?: string;\n    lineCount?: number;\n    speed?: number;\n    strokeWidth?: number;\n    darkColor?: string;\n    lightColor?: string;\n    backgroundColor?: string;\n}\n\nconst clamp = (value: number, min: number, max: number) => Math.min(max, Math.max(min, value));\n\nconst lerp = (a: number, b: number, t: number) => a + (b - a) * t;\n\nconst hexToRgb = (hex: string) => {\n    const normalized = hex.replace(\"#\", \"\");\n    const full =\n        normalized.length === 3\n            ? normalized\n                  .split(\"\")\n                  .map((char) => char + char)\n                  .join(\"\")\n            : normalized;\n\n    const value = Number.parseInt(full, 16);\n    return {\n        r: (value >> 16) & 255,\n        g: (value >> 8) & 255,\n        b: value & 255,\n    };\n};\n\nconst blendHex = (startHex: string, endHex: string, ratio: number, alpha: number) => {\n    const t = clamp(ratio, 0, 1);\n    const start = hexToRgb(startHex);\n    const end = hexToRgb(endHex);\n\n    const r = Math.round(lerp(start.r, end.r, t));\n    const g = Math.round(lerp(start.g, end.g, t));\n    const b = Math.round(lerp(start.b, end.b, t));\n\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n};\n\nexport const WaveRibbonBackground = ({\n    className,\n    lineCount = 36,\n    speed = 0.55,\n    strokeWidth = 1.5,\n    darkColor = \"#caa0ff\",\n    lightColor = \"#8fd6ff\",\n    backgroundColor = \"#0f1228\",\n}: WaveRibbonBackgroundProps) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n\n        const context = canvas.getContext(\"2d\");\n        if (!context) return;\n\n        let animationFrame = 0;\n        let width = 0;\n        let height = 0;\n        let dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));\n\n        const resizeCanvas = () => {\n            const rect = canvas.getBoundingClientRect();\n            width = rect.width;\n            height = rect.height;\n            dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));\n\n            canvas.width = Math.floor(width * dpr);\n            canvas.height = Math.floor(height * dpr);\n            canvas.style.width = `${width}px`;\n            canvas.style.height = `${height}px`;\n\n            context.setTransform(dpr, 0, 0, dpr, 0, 0);\n            context.lineCap = \"round\";\n            context.lineJoin = \"round\";\n        };\n\n        resizeCanvas();\n\n        const observer = new ResizeObserver(() => resizeCanvas());\n        observer.observe(canvas);\n\n        const draw = (timestamp: number) => {\n            const t = (timestamp / 1000) * speed;\n            const safeCount = Math.max(8, lineCount);\n            const centerY = height * 0.55;\n            const spacing = Math.max(2.8, Math.min(4.8, height / (safeCount * 1.9)));\n            const baseAmplitude = Math.max(14, Math.min(56, height * 0.12));\n            const frequency = (Math.PI * 2) / Math.max(320, width * 0.72);\n            const secondFrequency = frequency * 1.65;\n            const lineLength = width + 100;\n            const startX = -50;\n            const step = Math.max(3.5, width / 160);\n\n            context.fillStyle = backgroundColor;\n            context.fillRect(0, 0, width, height);\n\n            for (let index = 0; index < safeCount; index += 1) {\n                const normalized = safeCount <= 1 ? 0.5 : index / (safeCount - 1);\n                const centered = normalized - 0.5;\n                const offsetY = centered * spacing * safeCount;\n                const envelope = 1 - Math.min(1, Math.abs(centered) * 1.6);\n\n                const primaryAmplitude = baseAmplitude * (0.35 + envelope * 0.7);\n                const secondaryAmplitude = primaryAmplitude * 0.22;\n                const linePhase = centered * 3.1;\n                const wobble = Math.sin(t * 0.55 + centered * 5.4) * 5.5;\n                const alpha = clamp(0.2 + envelope * 0.55, 0.15, 0.8);\n\n                context.beginPath();\n                for (let x = startX; x <= lineLength; x += step) {\n                    const y =\n                        centerY +\n                        offsetY +\n                        wobble +\n                        Math.sin(x * frequency + t * 1.7 + linePhase) * primaryAmplitude +\n                        Math.sin(x * secondFrequency - t * 1.15 + centered * 2.3) * secondaryAmplitude;\n\n                    if (x === startX) {\n                        context.moveTo(x, y);\n                    } else {\n                        context.lineTo(x, y);\n                    }\n                }\n\n                context.strokeStyle = blendHex(darkColor, lightColor, normalized, alpha);\n                context.lineWidth = strokeWidth;\n                context.stroke();\n            }\n\n            animationFrame = window.requestAnimationFrame(draw);\n        };\n\n        animationFrame = window.requestAnimationFrame(draw);\n\n        return () => {\n            observer.disconnect();\n            window.cancelAnimationFrame(animationFrame);\n        };\n    }, [backgroundColor, darkColor, lightColor, lineCount, speed, strokeWidth]);\n\n    return <canvas ref={canvasRef} className={cn(\"absolute inset-0 h-full w-full\", className)} aria-hidden=\"true\" />;\n};\n",
      "type": "registry:ui",
      "target": "components/navyaui/WaveRibbonBackground.tsx"
    }
  ],
  "tailwind": {}
}